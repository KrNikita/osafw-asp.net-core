// Users model class
//
// Part of ASP.NET osa framework  www.osalabs.com/osafw/asp.net
// (c) 2009-2021 Oleg Savchuk www.osalabs.com

//if you use Roles - uncomment define isRoles here
#define isRoles

using System;
using Microsoft.VisualBasic;
using System.Collections;
using static BCrypt.Net.BCrypt;
using System.Text.RegularExpressions;

namespace osafw;

public class Users : FwModel
{
    // ACL constants
    public const int ACL_VISITOR = 0; //non-logged visitor
    public const int ACL_MEMBER = 1; //min access level for users
    public const int ACL_EMPLOYEE = 50;
    public const int ACL_MANAGER = 80;
    public const int ACL_ADMIN = 90;
    public const int ACL_SITEADMIN = 100;

    public const string PERM_COOKIE_NAME = "osafw_perm";
    public const int PERM_COOKIE_DAYS = 356;

    private readonly string table_menu_items = "menu_items";
    private readonly string table_users_cookies = "users_cookies";

    public Users() : base()
    {
        table_name = "users";
        csv_export_fields = "id fname lname email add_time";
        csv_export_headers = "id,First Name,Last Name,Email,Registered";
    }

    #region standard one/add/update overrides
    public Hashtable oneByEmail(string email)
    {
        Hashtable where = new();
        where["email"] = email;
        return db.row(table_name, where);
    }

    /// <summary>
    /// return full user name - First Name Last Name
    /// </summary>
    /// <param name="id">Object type because if upd_users_id could be null</param>
    /// <returns></returns>
    public new string iname(object id)
    {
        string result = "";

        int iid = Utils.f2int(id);
        if (iid > 0)
        {
            var item = one(iid);
            result = item["fname"] + "  " + item["lname"];
        }

        return result;
    }

    // check if user exists for a given email
    public override bool isExists(object uniq_key, int not_id)
    {
        return isExistsByField(uniq_key, not_id, "email");
    }

    public override int add(Hashtable item)
    {
        if (!item.ContainsKey("access_level"))
            item["access_level"] = Users.ACL_MEMBER;

        if (!item.ContainsKey("pwd"))
            item["pwd"] = Utils.getRandStr(8); // generate password
        item["pwd"] = this.hashPwd((string)item["pwd"]);
        return base.add(item);
    }

    public override bool update(int id, Hashtable item)
    {
        if (item.ContainsKey("pwd"))
            item["pwd"] = this.hashPwd((string)item["pwd"]);
        return base.update(id, item);
    }

    // return standard list of id,iname where status=0 order by iname
    public override DBList list()
    {
        string sql = "select id, fname+' '+lname as iname from " + db.qid(table_name) + " where status=0 order by fname, lname";
        return db.arrayp(sql);
    }

    public override ArrayList listSelectOptions(Hashtable def = null)
    {
        string sql = "select id, fname+' '+lname as iname from " + db.qid(table_name) + " where status=0 order by fname, lname";
        return db.arrayp(sql);
    }
    #endregion

    #region Work with Passwords
    /// <summary>
    /// performs any required password cleaning (for now - just limit pwd length at 32 and trim)
    /// </summary>
    /// <param name="plain_pwd">non-encrypted plain pwd</param>
    /// <returns>clean plain pwd</returns>
    public string cleanPwd(string plain_pwd)
    {
        return Strings.Trim(Strings.Left(plain_pwd, 32));
    }

    /// <summary>
    /// generate password hash from plain password
    /// </summary>
    /// <param name="plain_pwd">plain pwd</param>
    /// <returns>hash using https://github.com/BcryptNet/bcrypt.net </returns>
    public string hashPwd(string plain_pwd)
    {
        try
        {
            return EnhancedHashPassword(cleanPwd(plain_pwd));
        }
        catch (Exception)
        {
        }
        return "";
    }

    /// <summary>
    /// return true if plain password has the same hash as provided
    /// </summary>
    /// <param name="plain_pwd">plain pwd from user input</param>
    /// <param name="pwd_hash">password hash previously generated by hashPwd</param>
    /// <returns></returns>
    public bool checkPwd(string plain_pwd, string pwd_hash)
    {
        try
        {
            return EnhancedVerify(cleanPwd(plain_pwd), pwd_hash);
        }
        catch (Exception)
        {
        }
        return false;
    }

    /// <summary>
    /// generate reset token, save to users and send pwd reset link to the user
    /// </summary>
    /// <param name="id"></param>
    /// <returns></returns>
    public bool sendPwdReset(int id)
    {
        var pwd_reset_token = Utils.getRandStr(50);

        Hashtable item = new()
        {
            {"pwd_reset", this.hashPwd(pwd_reset_token)},
            {"pwd_reset_time", DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")}
        };
        this.update(id, item);

        var user = this.one(id);
        user["pwd_reset_token"] = pwd_reset_token;

        return fw.sendEmailTpl((string)user["email"], "email_pwd.txt", user);
    }

    /// <summary>
    /// evaluate password's stength and return a score (>60 good, >80 strong)
    /// </summary>
    /// <param name="pwd"></param>
    /// <returns></returns>
    public double scorePwd(string pwd)
    {
        var result = 0;
        if (string.IsNullOrEmpty(pwd))
            return result;

        // award every unique letter until 5 repetitions
        Hashtable chars = new();
        for (var i = 0; i <= pwd.Length - 1; i++)
        {
            chars[pwd[i]] = Utils.f2int(chars[pwd[i]]) + 1;
            result += (int)(5.0 / (double)chars[pwd[i]]);
        }

        // bonus points for mixing it up
        Hashtable vars = new()
        {
            {"digits",Regex.IsMatch(pwd, @"\d")},
            {"lower",Regex.IsMatch(pwd, "[a-z]")},
            {"upper",Regex.IsMatch(pwd, "[A-Z]")},
            {"other",Regex.IsMatch(pwd, @"\W")}
        };
        var ctr = 0;
        foreach (bool value in vars.Values)
        {
            if (value) ctr += 1;
        }
        result += (ctr - 1) * 10;

        // adjust for length
        result = (int)(Math.Log(pwd.Length) / Math.Log(8)) * result;

        return result;
    }
    #endregion

    #region Login/Session
    // fill the session and do all necessary things just user authenticated (and before redirect
    public bool doLogin(int id)
    {
        fw.context.Session.Clear();
        fw.Session("XSS", Utils.getRandStr(16));

        reloadSession(id);

        fw.logEvent("login", id);
        // update login info
        Hashtable fields = new();
        fields["login_time"] = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
        this.update(id, fields);
        return true;
    }

    public bool reloadSession(int id = 0)
    {
        if (id == 0)
            id = fw.userId;
        var user = one(id);

        fw.Session("user_id", Utils.f2str(id));
        fw.Session("login", (string)user["email"]);
        fw.Session("access_level", (string)user["access_level"]); //note, set as string
        fw.Session("lang", (string)user["lang"]);
        fw.Session("ui_theme", (string)user["ui_theme"]);
        fw.Session("ui_mode", (string)user["ui_mode"]);
        // fw.SESSION("user", hU)

        var fname = ((string)user["fname"]).Trim();
        var lname = ((string)user["lname"]).Trim();
        if (!string.IsNullOrEmpty(fname) || !string.IsNullOrEmpty(lname))
            fw.Session("user_name", fname + Interaction.IIf(!string.IsNullOrEmpty(fname), " ", "") + lname);
        else
            fw.Session("user_name", (string)user["email"]);

        var avatar_link = "";
        if (Utils.f2int(user["att_id"]) > 0)
            avatar_link = fw.model<Att>().getUrl(Utils.f2int(user["att_id"]), "s");
        fw.Session("user_avatar_link", avatar_link);

        return true;
    }
    #endregion

    #region Access Control
    /// <summary>
    /// return true if currently logged user has at least minimum requested access level
    /// </summary>
    /// <param name="min_acl">minimum required access level</param>
    /// <returns></returns>
    public bool isAccessLevel(int min_acl)
    {
        int users_acl = Utils.f2int(fw.Session("access_level"));
        return users_acl >= min_acl;
    }

    /// <summary>
    /// if currently logged user has at least minimum requested access level. Throw AuthException if user's acl is not enough
    /// </summary>
    /// <param name="min_acl">minimum required access level</param>
    public void checkAccessLevel(int min_acl)
    {
        if (!isAccessLevel(min_acl))
        {
            throw new AuthException();
        }
    }

    /// <summary>
    /// return true if user is ReadOnly user
    /// </summary>
    /// <param name="id">optional, if not passed - currently logged user checked</param>
    /// <returns></returns>
    public bool isReadOnly(int id = -1)
    {
        var result = false;
        if (id == -1)
            id = fw.userId;

        if (id <= 0)
            return true; //if no user logged - readonly

        var user = one(id);
        if (Utils.f2bool(user["is_readonly"]))
            result = true;

        return result;
    }

    /// <summary>
    /// check if logged user is readonly, if yes - throws AuthEception
    /// </summary>
    /// <param name="id">optional, if not passed - currently logged user checked</param>
    /// <exception cref="AuthException"></exception>
    public void checkReadOnly(int id = -1)
    {
        if (isReadOnly(id))
            throw new AuthException();
    }

    /// <summary>
    /// check if currently logged user roles has access to controller/action
    /// </summary>
    /// <param name="users_id">usually currently logged user - fw.userId</param>
    /// <param name="resource_icode">resource code like controller name 'AdminUsers'</param>
    /// <param name="resource_action">resource action like controller's action 'Index' or '' </param>
    /// <param name="resource_action_more">optional additional action string, usually route.action_more to help distinguish sub-actions</param>  
    /// <returns></returns>
    public bool isAccessByRolesResourceAction(int users_id, string resource_icode, string resource_action, string resource_action_more = "", Hashtable access_actions_to_permissions = null)
    {

#if isRoles
        // determine permission by resource action
        var permission_icode = fw.model<Permissions>().mapActionToPermission(resource_action, resource_action_more);

        if (access_actions_to_permissions != null)
        {
            //check if we have controller's permission's override for the action
            if (access_actions_to_permissions.ContainsKey(permission_icode))
                permission_icode = (string)access_actions_to_permissions[permission_icode];
        }

        var result = isAccessByRolesResourcePermission(users_id, resource_icode, permission_icode);
        if (!result)
            logger(LogLevel.DEBUG, "Access by Roles denied", new Hashtable {
                {"resource_icode", resource_icode },
                {"resource_action", resource_action },
                {"resource_action_more", resource_action_more },
                {"permission_icode", permission_icode },
                {"access_actions_to_permissions", access_actions_to_permissions },
            });
#else
        var result = true; //if no Roles support - always allow
#endif

        return result;
    }

    /// <summary>
    /// check if currently logged user roles has access to resource with specific permission
    /// </summary>
    /// <param name="users_id"></param>
    /// <param name="resource_icode"></param>
    /// <param name="permission_icode"></param>
    /// <returns></returns>
    public bool isAccessByRolesResourcePermission(int users_id, string resource_icode, string permission_icode)
    {
#if isRoles
        // read resource id
        var resource = fw.model<Resources>().oneByIcode(resource_icode);
        if (resource.Count == 0)
            return false; //if no resource defined - access denied
        var resources_id = Utils.f2int(resource["id"]);

        var permission = fw.model<Permissions>().oneByIcode(permission_icode);
        if (permission.Count == 0)
            return false; //if no permission defined - access denied
        var permissions_id = Utils.f2int(permission["id"]);

        // read all roles for user
        var roles_ids = fw.model<UsersRoles>().colLinkedIdsByMainId(users_id);

        // check if any of user's roles has access to resource/permission
        var result = fw.model<RolesResourcesPermissions>().isExistsByResourcePermissionRoles(resources_id, permissions_id, roles_ids);
        if (!result)
            logger(LogLevel.DEBUG, "Access by Roles denied", DB.h("resource_icode", resource_icode, "permission_icode", permission_icode));
#else
        var result = true; //if no Roles support - always allow
#endif
        return result;
    }


    #endregion

    #region Permanent Login Cookies
    public string createPermCookie(int id)
    {
        long curTS = new DateTimeOffset(DateTime.UtcNow).ToUnixTimeSeconds();
        string rnd = curTS.ToString() + Utils.getRandStr(32);
        string cookieId = rnd.Substring(0, 32);

        var fields = DB.h("cookie_id", cookieId, "users_id", id);
        db.updateOrInsert(table_users_cookies, fields, DB.h("users_id", id));

        Utils.createCookie(fw, PERM_COOKIE_NAME, cookieId, curTS + 60 * 60 * 24 * PERM_COOKIE_DAYS);

        return cookieId;
    }

    public bool checkPermanentLogin()
    {
        var cookieId = Utils.getCookie(fw, PERM_COOKIE_NAME);
        if (!string.IsNullOrEmpty(cookieId))
        {
            DBRow row = db.row(table_users_cookies, DB.h("cookie_id", cookieId));
            if (row.Count > 0)
            {
                doLogin(Utils.f2int(row["users_id"]));
                return true;
            }
            else
            {
                Utils.deleteCookie(fw, PERM_COOKIE_NAME);
            }
        }
        return false;
    }

    public void removePermCookie(int id)
    {
        Utils.deleteCookie(fw, PERM_COOKIE_NAME);
        db.del(table_users_cookies, DB.h("users_id", id));
        db.del(table_users_cookies, DB.h("add_time", db.opLE(DateTime.Now.AddYears(-1)))); // also cleanup old records (i.e. force re-login after a year)
    }
    #endregion

    public void loadMenuItems()
    {
        ArrayList menu_items = (ArrayList)FwCache.getValue("menu_items");

        if (menu_items == null)
        {
            // read main menu items for sidebar
            menu_items = db.array(table_menu_items, DB.h("status", STATUS_ACTIVE), "iname");
            FwCache.setValue("menu_items", menu_items);
        }

        // only Menu items user can see per ACL
        var users_acl = Utils.f2int(fw.Session("access_level"));
        ArrayList result = new();
        foreach (Hashtable item in menu_items)
        {
            if (Utils.f2int(item["access_level"]) <= users_acl)
                result.Add(item);
        }

        fw.G["menu_items"] = result;
    }

}